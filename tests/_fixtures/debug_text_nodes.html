<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Debug Text Nodes - Pangu.js</title>
    <style>
        body { 
            font-family: monospace; 
            padding: 20px;
            line-height: 1.8;
        }
        .test-case {
            border: 1px solid #ccc;
            padding: 10px;
            margin: 10px 0;
            background: #f5f5f5;
        }
        .debug-output {
            background: #333;
            color: #0f0;
            padding: 10px;
            margin: 10px 0;
            white-space: pre-wrap;
            font-size: 12px;
        }
        .node-info {
            background: #e0e0e0;
            padding: 5px;
            margin: 2px 0;
        }
        .text-node { color: blue; }
        .element-node { color: red; }
    </style>
</head>
<body>
    <h1>Text Node Debugging Tool</h1>
    
    <!-- Test Case 1: Exact structure from browser console -->
    <div class="test-case">
        <h3>Test Case 1: Split Text Nodes (社"DF)</h3>
        <div id="test1" class="original">
            <span>社</span>"<span>DF</span>
        </div>
        <div class="debug-output" id="debug1"></div>
    </div>

    <!-- Test Case 2: Complex quote structure -->
    <div class="test-case">
        <h3>Test Case 2: Complex Quote Structure</h3>
        <div id="test2" class="original">
            前面的文字"<span>中间的内容</span>"后面的文字
        </div>
        <div class="debug-output" id="debug2"></div>
    </div>

    <!-- Test Case 3: Nested elements with quotes -->
    <div class="test-case">
        <h3>Test Case 3: Nested with Multiple Quotes</h3>
        <div id="test3" class="original">
            <div>外层"<span>内层"<em>更深</em>"回来</span>"结束</div>
        </div>
        <div class="debug-output" id="debug3"></div>
    </div>

    <!-- Test Case 4: Dynamic content -->
    <div class="test-case">
        <h3>Test Case 4: Dynamically Created Content</h3>
        <div id="test4" class="original"></div>
        <div class="debug-output" id="debug4"></div>
    </div>

    <script>
        // Helper function to analyze DOM structure
        function analyzeNode(node, depth = 0) {
            const indent = '  '.repeat(depth);
            let output = '';
            
            if (node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent;
                const escaped = text.replace(/\n/g, '\\n').replace(/\s/g, '·');
                output += `${indent}<span class="text-node">TEXT: "${escaped}" (length: ${text.length})</span>\n`;
                
                // Check if this text node contains quotes
                if (text.includes('"') || text.includes('"') || text.includes('"')) {
                    output += `${indent}  → Contains quotes!\n`;
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                output += `${indent}<span class="element-node">&lt;${node.tagName.toLowerCase()}&gt;</span>\n`;
                
                // Analyze child nodes
                for (let child of node.childNodes) {
                    output += analyzeNode(child, depth + 1);
                }
                
                output += `${indent}<span class="element-node">&lt;/${node.tagName.toLowerCase()}&gt;</span>\n`;
            }
            
            return output;
        }

        // Function to process text with pangu-like logic
        function processTextNode(textNode) {
            const text = textNode.textContent;
            console.log('Processing text node:', JSON.stringify(text));
            
            // Simple simulation of pangu.js spacing logic
            const processed = text
                .replace(/([a-zA-Z])(["])/g, '$1 $2')  // Space before opening quote
                .replace(/(["])([a-zA-Z])/g, '$1 $2')  // Space after closing quote
                .replace(/([一-龥])([a-zA-Z0-9])/g, '$1 $2')  // CJK followed by alphanumeric
                .replace(/([a-zA-Z0-9])([一-龥])/g, '$1 $2'); // Alphanumeric followed by CJK
            
            return processed;
        }

        // Function to walk through all text nodes
        function walkTextNodes(node, callback) {
            if (node.nodeType === Node.TEXT_NODE) {
                callback(node);
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                for (let child of node.childNodes) {
                    walkTextNodes(child, callback);
                }
            }
        }

        // Analyze each test case
        function analyzeTestCase(testId, debugId) {
            const testElement = document.getElementById(testId);
            const debugElement = document.getElementById(debugId);
            
            // Clone the element to preserve original
            const clone = testElement.cloneNode(true);
            
            // Show original structure
            debugElement.innerHTML = '<strong>Original DOM Structure:</strong>\n';
            debugElement.innerHTML += analyzeNode(testElement);
            
            // Process text nodes
            debugElement.innerHTML += '\n<strong>Text Node Processing:</strong>\n';
            walkTextNodes(clone, (textNode) => {
                const original = textNode.textContent;
                const processed = processTextNode(textNode);
                if (original !== processed) {
                    debugElement.innerHTML += `Changed: "${original}" → "${processed}"\n`;
                    textNode.textContent = processed;
                }
            });
            
            // Show processed structure
            debugElement.innerHTML += '\n<strong>Processed DOM Structure:</strong>\n';
            debugElement.innerHTML += analyzeNode(clone);
            
            // Show final HTML
            debugElement.innerHTML += '\n<strong>Final HTML:</strong>\n';
            debugElement.innerHTML += clone.innerHTML.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        // Create dynamic content for test case 4
        document.addEventListener('DOMContentLoaded', function() {
            const test4 = document.getElementById('test4');
            
            // Create fragmented text nodes like the browser might
            test4.appendChild(document.createTextNode('动态'));
            test4.appendChild(document.createTextNode('"'));
            const span = document.createElement('span');
            span.textContent = 'API';
            test4.appendChild(span);
            test4.appendChild(document.createTextNode('"'));
            test4.appendChild(document.createTextNode('内容'));
            
            // Run analysis on all test cases
            analyzeTestCase('test1', 'debug1');
            analyzeTestCase('test2', 'debug2');
            analyzeTestCase('test3', 'debug3');
            analyzeTestCase('test4', 'debug4');
        });

        // Additional debugging: monitor mutations
        const observer = new MutationObserver((mutations) => {
            console.log('DOM Mutations detected:', mutations);
        });

        // Start observing
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            characterData: true
        });
    </script>
</body>
</html>